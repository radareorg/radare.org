<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advent Of Radare2</title>
  <link rel="stylesheet" type="text/css" href="index.css">
</head>
<body>
  <a href="/advent">/advent</a>
<h1 id="parsing-headers">22 - Parsing Headers</h1>
<p>Welcome to Day 22th of the Advent of Radare!</p>
<p>Today, we’re focusing on analyzing binary file formats, specifically
by examining their headers and loading their data. Understanding the
structure of a binary format provides valuable insights into its
metadata, dependencies, and setup instructions, which can reveal
important information about its behavior and compatibility.</p>
<p>Radare2’s <code>i</code> command provides basic information, while
<code>ih</code> and <code>iH</code> allow us to explore parsed headers
in detail. We can use the <code>*</code> suffix to create an r2 script
to import all the header metadata into radare2 as flags
(<code>ih*</code>) for easy navigation and referencing.</p>
<p>Additionally, we’ll explore <code>rabin2</code>, a powerful companion
tool that enables binary manipulation, header modification, and even the
creation of minimal executables with custom code. We’ll also learn how
to use the <code>ob</code> command to manage multiple binary files in
memory, which is particularly useful when analyzing complex programs
with shared libraries or when comparing different versions of the same
binary.</p>
<h2 id="generic-vs-specific">Generic vs Specific</h2>
<p>We learned in previous posts that <strong>RBin</strong> aims to use
generic concepts to describe all the information contained in the
executable binaries. This is a design decision to ease the reusability
of scripts and reduce the learning curve for users when start to work on
new file formats or switch between different architectures.</p>
<p>But when refering to binary headers, we can’t be generic, because we
want to understand the real structures with it’s custom attributes and
fields.</p>
<p>We won’t usually need to mess with that, but when we need to, we will
really love to be able to parse and manipulate them at our will, which
may be handy for several applications:</p>
<ul>
<li>Create custom crackmes</li>
<li>Bypass protections</li>
<li>Patch dumped binaries</li>
<li>Change attributes or permissions</li>
<li>Add or resize sections</li>
</ul>
<h2 id="headers">Headers</h2>
<ul>
<li><p>However, to analyze the file’s headers in detail, we’ll go deeper
with ih and iH, which provide a breakdown of each header and its
specific fields.</p></li>
<li><p>Parsing Detailed Header Information with ih and iH</p></li>
<li><p>The ih command displays parsed header fields in a structured
format, including addresses, offsets, and types. This is particularly
useful when working with complex binary formats, such as Mach-O or ELF,
where headers contain detailed setup instructions for loading the
binary.</p></li>
</ul>
<h2 id="annotated-hexdump">Annotated Hexdump</h2>
<p>In <strong>radare2</strong>, there are various ways to display
labels, comments, and colorized regions in hexdumps, but we need to use
specific commands to achieve this. Let’s start with manual annotations
and then learn which commands can be used to import parsed metadata from
headers.</p>
<p><strong>NOTE:</strong> One of the key advantages of using radare2 for
file format analysis is that you can modify any parser if you have the
source code, or hook functions using <a
href="https://frida.re">Frida</a> to generate logs in the form of r2
commands. These commands can add comments and label offsets, which can
then be used for static analysis.</p>
<p>Let’s begin by trying the <code>pxa</code> command on a malloc://32.
The <code>-f</code> flag sets the blocksize equal to the file size,
allowing us to display the entire contents with any print command
without needing to specify the size.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> r2 <span class="at">-f</span> malloc://32</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">[0x00000000]</span><span class="op">&gt;</span> xa</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">-</span> offset <span class="at">-</span>   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ex">0x00000000</span>  0000 0000 0000 0000 0000 0000 0000 0000  ................</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ex">0x00000010</span>  0000 0000 0000 0000 0000 0000 0000 0000  ................</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ex">[0x00000000]</span><span class="op">&gt;</span> q</span></code></pre></div>
<p>At first the output of <code>pxa</code> will look the same as
<code>px</code>. But hey! did you noticed that we typed <code>xa</code>?
This is because <code>x</code> is the short alias of <code>px</code>. So
for practical reasons you can save one char everytime you heXdump.</p>
<p>Let’s add a comment and a couple of flags and see what happens:</p>
<pre class="console"><code>[0x00000000]&gt; f hello @ 4
[0x00000000]&gt; f world @ 20
[0x00000000]&gt; CC my comment @ 24
[0x00000000]&gt; xa
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
                      /hello
0x00000000  0000 0000 0000 0000 0000 0000 0000 0000  ................
                      /world    ;my comment
0x00000010  0000 0000 0000 0000 0000 0000 0000 0000  ................ ; my comment
[0x00000000]&gt;</code></pre>
<p>Now things look clearer, right? Another cool and barely known feature
of flags is that you can you can assign a color to them, as well as a
size and a comment. With these attributes the <code>pxa</code> output
will adjust the bounds to colorize each flag in a proper way.</p>
<pre class="console"><code>[0x00000000]&gt; f?~color,comment
| f name 12 33 [cmt]        same as above + optional comment
| fc[?][name] [color]       set color for given flag
| fC [name] [cmt]           set comment for given flag</code></pre>
<h2 id="header-annotations">Header Annotations</h2>
<p>Now we will learn how to import all the flags (<code>f</code>),
comments (<code>CC</code>), formats (<code>pf</code>), and data
definitions (<code>Cd</code>) into radare2 to make the headers look
better in both <code>pxa</code> and <code>pd</code> views.</p>
<p>You may have noticed that most tools assume everything you read is
data unless you specify it as code. Radare takes a different approach:
when disassembling with <code>pd</code>, it assumes everything is code
unless specified as data. You can mark regions as data using the
<code>Cd</code> and <code>Cf</code> commands. To remove metadata
annotations, you can use the <code>C-</code> command.</p>
<p>To load struct definitions and formats (<code>pf</code>) from rbin,
you can use the <code>pfo</code> command.</p>
<pre class="console"><code>[0x00000000]&gt; pfo
bios.r2
cdex.h
dex.h
dex.r2
elf32.r2
elf64.r2
elf_enums.r2
fatmacho.r2
jni.h
macho.r2
mz.r2
ntfs.r2
pe32.r2
trx.r2
zip.r2
[0x00000000]&gt;</code></pre>
<p>The <code>libr/bin/d</code> directory from the radare2 source code
contains a bunch of structs defined using the <code>pf</code> command.
Read <code>pf?</code> and <code>pf??</code> help messages to see the
format string you can use to interpret data as code.</p>
<pre class="console"><code>[0x00000000]&gt; pfo elf32.r2
[0x00000000]&gt; pf.
pf.elf_header ?[2]E[2]E[4]ExxxxN2N2N2N2N2N2 (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx
pf.elf_ident [4]z[1]E[1]E[1]E.:: magic (elf_class)class (elf_data)data (elf_hdr_version)version
pf.elf_phdr [4]Exxxxx[4]Ex (elf_p_type)type offset vaddr paddr filesz memsz (elf_p_flags)flags align
pf.elf_shdr x[4]E[4]Exxxxxxx name (elf_s_type)type (elf_s_flags_32)flags addr offset size link info addralign entsize
[0x00000000]&gt;</code></pre>
<p>We have loaded the struct definitions, but we don’t know yet where
those types must be applied in memory. To do that we will need to use
the <code>.ih*</code> command that will set the flags and use
<code>Cf</code> to <em>bind</em> them into specific offsets.</p>
<h2 id="header-information">Header Information</h2>
<p>Let’s take a look at the output of <code>ih</code> for an ELF
file.</p>
<pre class="console"><code>$ r2 test/bins/elf/ls
[0x00005ae0]&gt; ih
0x00000000 0x00000000 0x464c457f ELF
0x00000010 0x00000010 0x00000003 Type
0x00000012 0x00000012 0x0000003e Machine
0x00000014 0x00000014 0x00000001 Version
0x00000018 0x00000018 0x00005ae0 EntryPoint
0x00000020 0x00000020 0x00000040 PhOff
0x00000028 0x00000028 0x00021368 ShOff
0x00000030 0x00000030 0x00000000 Flags
0x00000034 0x00000034 0x00000040 EhSize
0x00000036 0x00000036 0x00000038 PhentSize
0x00000038 0x00000038 0x0000000b PhNum
0x0000003a 0x0000003a 0x00000040 ShentSize
0x0000003c 0x0000003c 0x00000019 ShNum
0x0000003e 0x0000003e 0x00000018 ShrStrndx
[0x00005ae0]&gt; iH
0x00000000  ELF64       0x464c457f
0x00000010  Type        0x0003
0x00000012  Machine     0x003e
0x00000014  Version     0x00000001
0x00000018  Entrypoint  0x00005ae0
0x00000020  PhOff       0x00000040
0x00000028  ShOff       0x00021368
0x00000030  Flags       0x00000000
0x00000034  EhSize      64
0x00000036  PhentSize   56
0x00000038  PhNum       11
0x0000003a  ShentSize   64
0x0000003c  ShNum       25
0x0000003e  ShrStrndx   24
[0x00005ae0]&gt;</code></pre>
<p>Comparing that to the output to a macho file, we will see how much
different it is:</p>
<pre class="console"><code>[0x100003a58]&gt; ih
0x100000000 0x00000000 0x00000000 header; mach0_header
0x100000020 0x00000020 0x00000001 load_command_0_LC_SEGMENT_64; mach0_segment64
0x100000068 0x00000068 0x00000001 load_command_1_LC_SEGMENT_64; mach0_segment64
0x100000240 0x00000240 0x00000001 load_command_2_LC_SEGMENT_64; mach0_segment64
0x100000378 0x00000378 0x00000001 load_command_3_LC_SEGMENT_64; mach0_segment64
0x1000004b0 0x000004b0 0x00000001 load_command_4_LC_SEGMENT_64; mach0_segment64
0x100000518 0x00000518 0x00000001 load_command_7_LC_SYMTAB; mach0_symtab_command
0x100000530 0x00000530 0x00000001 load_command_8_LC_DYSYMTAB; mach0_dysymtab_command
0x100000580 0x00000580 0x00000001 load_command_9_LC_LOAD_DYLINKER; mach0_load_dylinker_command
...
[0x100003a58]&gt; iH
pf.mach0_header @ 0x100000000
0x100000000  Magic       0xfeedfacf
0x100000004  CpuType     0x100000c
0x100000008  CpuSubType  0x80000002
0x10000000c  FileType    0x2
0x100000010  nCmds       20
0x100000014  sizeOfCmds  1712
...</code></pre>
<p>If you’re familiar with these file formats, you’ll notice that the
output is missing some fields and details. This occurs partly because
certain details are automatically inferred from the <code>pf</code>
types when loaded through <code>.ih*</code>. Additionally, radare2’s
commands and features continuously evolve based on user requirements. If
you’re interested in extending, learning about, or improving support for
any of these file formats, I encourage you to examine them and
contribute enhancements.</p>
<p>Let’s analyze the output of the script generated by <code>ih*</code>
before we execute it.</p>
<pre class="console"><code>[0x100003a58]&gt; ih*
&#39;fs+header
&#39;f header.header 1 0x100000000
CCu base64:bWFjaDBfaGVhZGVy @ 0x100000000
Cf 1 mach0_header @ 0x100000000
&#39;f header.load_command_0_LC_SEGMENT_64 1 0x100000020
&#39;f header.load_command_0_LC_SEGMENT_64.value 1 0x00000001
CCu base64:bWFjaDBfc2VnbWVudDY0 @ 0x100000020
Cf -1 mach0_segment64 @ 0x100000020
&#39;f header.load_command_1_LC_SEGMENT_64 1 0x100000068
&#39;f header.load_command_1_LC_SEGMENT_64.value 1 0x00000001
CCu base64:bWFjaDBfc2VnbWVudDY0 @ 0x100000068
Cf -1 mach0_segment64 @ 0x100000068
&#39;f header.load_command_2_LC_SEGMENT_64 1 0x100000240
&#39;f header.load_command_2_LC_SEGMENT_64.value 1 0x00000001
...</code></pre>
<h2 id="binding-types">Binding Types</h2>
<p>When loading binaries in r2, the bin plugin specifies a default base
address depending on the file type. This base address can be overridden
with the <code>-B</code> command line flag and is also accessible
through the <code>bin.baddr</code> eval variable.</p>
<p>In some situations, runtime linkers manipulate program headers or
don’t map them in memory, requiring us to switch back to physical
addressing mode (<code>-e io.va=false</code>) and seek to address zero
to read them properly.</p>
<p>Alternatively, we can load the file using the <code>-n</code> command
line flag to prevent rbin from parsing headers or loading any
information from them.</p>
<p>Another interesting feature of radare2 is its ability to parse
binaries from memory at any address. This means we can analyze a binary
by specifying its location in a debugger process, firmware, or memory
dump without having to extract it to a separate file on disk.</p>
<p>This is accomplished using the <code>oba $$</code> command:</p>
<pre class="console"><code>0$ r2 -n radare2/test/bins/elf/ls
[0x00000000]&gt; ie              # no entrypoints, rbin data not loaded
[0x00000000]&gt; ob              # we confirm that no bin files opened
[0x00000000]&gt; oba $$
[0x00000000]&gt; ob
* 0 3 x86-64 ba:0x00000000 sz:136038 ../radare2/test/bins/elf/ls
[0x00000000]&gt; ie
paddr      vaddr      phaddr     vhaddr     type
――――――――――――――――――――――――――――――――――――――――――――――――
0x00005ae0 0x00005ae0 0x00000018 0x00000018 program
[0x00000000]&gt;</code></pre>
<p>With all the types we can view those values and manipulate them using
<code>wv4</code> or <code>wv8</code> to change the entrypoint, version
information, amount of elements in the program headers, etc</p>
<pre class="console"><code>$ r2 bins/elf/ls
[0x00000000]&gt; e io.va=0
[0x00000000]&gt; pfo elf64.r2
[0x00000000]&gt; .ih*
[0x00000014]&gt; pd 4 @ header.Version
            ;-- header.Version:
            0x00000014      .dword 0x00000001
            ;-- header.EntryPoint:
            ;-- header.ShrStrndx.value:
            0x00000018      .qword 0x0000000000005ae0 ; entry0 ; rip ; header.EntryPoint.value
            ;-- header.PhOff:
            0x00000020      .qword 0x0000000000000040
[0x00000014]&gt;</code></pre>
<h2 id="pava-mode">PaVa mode</h2>
<p>The <strong>pava</strong> mode is another lesser-known feature of
radare2 that can be particularly useful for users familiar with tools
like IDA. This mode displays offsets in disassembly/hexdump views using
virtual addresses while navigating through linear physical
addresses.</p>
<p>To illustrate: if you seek to offset 0 in a binary that’s mapped to
address 0x800000, the display will show it as if you were at address
0x800000.</p>
<p>This functionality is valuable because it provides a linear listing
following the file’s physical data while rendering it with virtual
addressing. This makes the disassembly more accurate and helps avoid
inconsistencies or complications that might arise from virtual
addressing and IO mappings.</p>
<pre class="console"><code>-e io.pava=true
-e io.va=false</code></pre>
<h2 id="challenge">Challenge</h2>
<p>Today’s challenge involves manipulating a binary to change its
behavior by modifying the binary file headers. Practice using the new
commands learned in this post and open the file using the
<code>r2 -nw</code> command-line flags to patch the headers.</p>
<ul>
<li><code>-n</code>: don’t parse the headers</li>
<li><code>-w</code>: open in write mode</li>
</ul>
<p>Spend some time identifying the entrypoint address specified in the
binary header using the <code>ih</code>, <code>ih*</code>, and
<code>iH</code> commands. Note that specifying the entrypoint differs
between ELF, PE, and MACH-O files - each file format has its own way to
tell the runtime linker how to execute the program. Familiarize yourself
with these details and then use <code>wv4</code> or <code>wv8</code> to
apply the changes.</p>
<p>Here’s a practical example:</p>
<ul>
<li>Take the <code>/bin/ls</code> binary</li>
<li>Locate the function that displays the help message</li>
<li>(This function typically just prints the help text and exits)</li>
<li>Modify the entrypoint to point to that function
<ul>
<li>Use <code>oo+</code> to reopen the file in read-write</li>
<li>Use <code>e io.va=0</code> to</li>
<li>Load the header flags with <code>.ih*</code></li>
<li>Use <code>wv8 fcnaddr</code> to patch the entrypoint</li>
</ul></li>
</ul>
<h2 id="final-words">Final Words</h2>
<p>You have probably thought about many different ways to improve these
workflows or spotted some bugs or inconsistencies in the output,
depending on the version of radare you are using.</p>
<p>Having such feedback and submitting patches to improve support for
various use cases in radare is a great way to learn and share those
improvements with others.</p>
<p>Stay tuned for tomorrow’s Radare2 challenge as we continue our
journey through advanced reverse engineering techniques!</p>
</body>
<script>
  function scaleImageMap() {
    const img = document.getElementById("advimg");
    const imgWidth = img.naturalWidth;
    const imgHeight = img.naturalHeight;
    const imgDisplayedWidth = img.offsetWidth;
    const scale = imgDisplayedWidth / imgWidth;

    document.querySelectorAll("#imgmap area").forEach((area) => {
      const originalCoords = area.dataset.originalCoords.split(",").map(Number);
      const scaledCoords = originalCoords.map(coord => Math.round(coord * scale));
      area.coords = scaledCoords.join(",");
    });
  }
  window.addEventListener("load", scaleImageMap);
  window.addEventListener("resize", scaleImageMap);
</script>
</html>
